
# 【Python学习分享文章】_ML_NumPy_基础介绍

## 综述

人工智能的发展，两方面基础原因：

- 计算机硬件发展
- 机器学习的“算法”

最主要的主要是 Python。

四大基础库：

1. NumPy
2. Pandas
3. TensorFlow
4. Matplotlib

机器学习的通用处理步骤：

1. 数据采集
2. 预处理（统一单位等等）
3. 清洗（处理缺失值、异常值）
4. 建模
5. 测试（通过测试的话就进行应用或者改善）

# ```NumPy```

主要用途：数据预处理。

用于高性能科学计算 & 数据分析，是常用的高级数据分析库的**基础包**。

C 语言开发，高效处理数据。

## 安装

在 电脑的终端 上使用如下命令进行安装：

```
pip install numpy
```

引入库：


```python
import numpy as np
```

【其他编译器可能问题】：

可能系统安装了的 NumPy 在高级一些的编译器里面无法引用，这时候最方便的做法就是把系统 Python 程序加入到编译器的环境中。

1. 在终端输入 ```which python``` 即可获得 Python 的路径
2. 将这个路径添加到引用环境中，以 PyCharm 为例，位置如下：  
File - Default Preferences - Project Interpreter - 齿轮按钮⚙ - add - System Interpreter - ... - 在方框里面赋值刚刚获得的路径 - 即可。
3. Run - Debug Configurations - Python - 自己创建的文件名对应的选项里面 - Python interpreter - 选择系统的解释器 - 搞定。


## 封装

**高级的** 地方：可以自动获取、分配数据类型。


```python
arr_1 = np.array([1, 45, 28])
```


```python
print(arr_1)  # 输出 NumPy 的列表
print(arr_1.dtype)  # 输出数据类型
```

    [ 1 45 28]
    int32
    

【解释】：

- 虽然都是列表，但是是 NumPy 的数据封装类型，计算效率高于 Python 自己的。(突然发现，这个的列表，中间是没有逗号“,”连接的）
- 自动转化得到数据类型

## 自动获取数据类型


```python
arr_2 = np.array([1.11, 2.24, 3.1415926])
print(arr_2)
print(arr_2.dtype)
```

    [1.11      2.24      3.1415926]
    float64
    

#### -- 数据类型

- int8, int16, int32, int64...
- float32, float64...

## 数学计算

### - 累加


```python
print(arr_1 + arr_2)
```

    [ 2.11      47.24      31.1415926]
    


```python
arr_3 = np.array([1, 22, 333, 4444])
```

#### -- 如果个数不一样呢？

结果就是报错，回想一下原理，就是数学里面，不一样的矩阵也是无法进行 ➕ 的运算，就像乘法，也是要行和列的个数要对应。

如下：


```python
print(arr_1 + arr_3)
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-7-9f6e14e79e9b> in <module>()
    ----> 1 print(arr_1 + arr_3)
    

    ValueError: operands could not be broadcast together with shapes (3,) (4,) 


### - 和标量计算

无需书写循环的语句，库自带的功能。

【标量】：  
有大小、无方向，如温度、体积等，速度是有方向，是【矢量】。


```python
print(arr_2)
print(arr_2 * 10)
print(arr_2 + 20)
```

    [1.11      2.24      3.1415926]
    [11.1      22.4      31.415926]
    [21.11      22.24      23.1415926]
    

## 二维数组

二维数组，是我们平时最常说的【矩阵】。

### - 创建


```python
data_3 = [[123, 10086, 2018], [1000, 23, 11]]  # 嵌套结构
arr_3 = np.array(data_3)

print(arr_3)
print(arr_3.dtype)
```

    [[  123 10086  2018]
     [ 1000    23    11]]
    int32
    

【观察】：

最后的输出结果是数据格式对齐的，very nice！

## - 创建特殊矩阵

### - 全为0

#### -- 一维情况

例子：建立一个“总长度=10”的一维矩阵，如下：


```python
sevenOne_ZeroMatrix = np.zeros(7)
print(sevenOne_ZeroMatrix)
```

    [0. 0. 0. 0. 0. 0. 0.]
    

#### -- 二维情况

注意：参数是要一个“（）”的 tuple 数据，作为整体输入。

建立一个 4*7 的二维零矩阵，如下：


```python
fourSevenTwo_ZeroMatrix = np.zeros((4, 7))  # 行数 * 列数
print(fourSevenTwo_ZeroMatrix)
```

    [[0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0.]]
    

### - 全为1

说法和 零矩阵 是一样的操作，如下：


```python
print(np.ones((3,5)))
```

    [[1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]]
    

### - 全为 空值

由于计算机是需要使用数字进行计算的，“空值”是无法计算、不安全的，因此，程序会自动添加随机的值进去。

建立一个三维的 空值 矩阵，如下：


```python
print(np.empty((3, 5, 6)))
```

    [[[ 1.48776246e+195  1.01156612e-153  6.06734379e-095  6.08166870e+247
        2.30227740e-070  8.48585409e-096]
      [ 5.50409570e+257  4.91347514e+252  6.01334668e-154  3.94645954e+180
        4.70108366e+180  1.42853562e+248]
      [ 3.54073738e+155  1.18588375e-089  9.39747671e-154  1.08615010e-153
        4.57551204e-072  1.23475802e-259]
      [ 1.94862140e-153  3.86585424e+233  2.46343043e-154  1.79805224e+044
        1.05894728e-153  3.94143213e+156]
      [ 5.36094582e+199  1.27276404e+232  1.78743824e+161  7.20218835e+252
        2.02763010e+174  2.46635954e-154]]
    
     [[ 2.41079391e+198  3.45061255e-085  9.31464415e+242  1.94860694e-153
        7.53046675e+252  5.98185637e-154]
      [ 1.74517827e+194  1.46923442e+195  8.02146756e+165  1.21698002e-152
        8.82085794e+199  2.00294436e+233]
      [ 1.10128260e+155  1.58690806e+262  2.29792410e+156  6.01347002e-154
        2.23220787e+271  2.55877511e-086]
      [ 2.23209619e+271  2.46598535e-154  4.47593816e-091  6.01346953e-154
        1.29504815e+171  6.11248939e+228]
      [ 1.17233372e+214  3.54073738e+155  9.57568602e+270  2.66538186e-260
        2.25563609e-153 -1.43594722e-310]]
    
     [[ 6.14830324e-071  1.94267486e-109  7.04142211e-009  4.41988634e+222
        4.32192832e+174  6.01334503e-154]
      [ 5.98152488e-154  1.01160582e-153  1.55489166e-259  3.13096583e+161
        1.46921889e+195  5.77538073e+228]
      [ 2.43194426e-152  6.85859700e+271  1.63656311e-027  7.01413727e-009
        3.52286671e-110  5.60157176e-067]
      [ 6.38796479e+029  1.27734658e-152  2.66541172e-260  2.25563609e-153
        6.01346954e-154  3.33304154e-090]
      [ 2.74072822e-057  1.05963964e-153  1.14217231e-071  9.98858524e+141
        7.01413727e-009  4.83847915e-109]]]
    

## 索引、切片功能

类似 序列 数据一样，进行切片功能，即“抓取部分数据”。

### - range 功能

索引序号的基础。

自带的是 ```range```，为了区别，np 的语法是 ```arange```。

序列数字也是从 0 开始进行计算的。

例子如下：


```python
rangeNp = np.arange(10)
print(rangeNp)
```

    [0 1 2 3 4 5 6 7 8 9]
    

### - 抓取序列数字

和 ```range``` 是一样的，如下：


```python
print(rangeNp[5:8])
```

    [5 6 7]
    

### - 进行赋值

**作用**：修改内容。

直接就可以进行“赋值”操作，如下：


```python
rangeNp[5:8] = 17

print(rangeNp)
```

    [ 0  1  2  3  4 17 17 17  8  9]
    

### - 重新赋值，不改变原有数据

逻辑：将对应数字“复制”出来，创建一个副本，再进行上述的处理，如下：


```python
arr_slice = rangeNp[5:8].copy()
arr_slice[:] = 21

print(rangeNp)
print(arr_slice)
```

    [ 0  1  2  3  4 17 17 17  8  9]
    [21 21 21]
    

【解释】：  
只是对复制（copy）出来作为副本的 arr_slice 进行数据的变更，不改变原有的数据。

## 总结

暂时这些，还不是太难。

这些特定值的矩阵有什么用呢？暂时不知道，先记下来先，对于0、1，知道的是矩阵里面的转化、计算，尤其是计算“矩阵的秩”是有很大用处的，“空值矩阵”就没有什么印象了。


---
注：  
个人微信公众号：codeAndWrite
